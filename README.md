# FIREWORKS: evolution and optimization

This repo collects the material related to the project carried out during the Computational Astrophysics course at the University of Padua. The supervisors were Dr. Giuliano Iorio, Dr. GastÃ³n Escobar and Marco Dall'Amico. 

## The project 

### Part 1 - Optimization and parallelization

#### CPU optimization

We assess different methods to optimize N-body simulations with Python on CPU. This task is approached in two ways:

1. Optimizing the computation of accelerations, for a given single simulation;

2. Optimizing independent simulations run in parallel.

For the first approach we use the built-in multiprocessing and the external `numba` library, while for the second only the former is considered.

We find a significant speed-up of the code in both cases, even though optimization fails when we try to mix the two methods, i.e. when running multiple independent simulations, while computing the accelerations in an optimized fashion.

#### GPU Brute Force Acceleration Estimation with `NUMBA` `CUDA`

We implemented a brute force method to estimate N-body accelerations and the velocity-verlet integrator as `CUDA` kernels. The goal is to parallelaise as much es possible the computations made within a single run and to achive parallelisation across multiple simulations.

One key limiting factor to the capabilities of these implementations is hardware related: Colaboratory (COLAB) has been use to develop and test the kernels and the gpus that are freely available on it are not particularly performant. Moreover intensive traffic on the network could impact negatively the performances.

In order to evolve different simulations (meaning different csystem configurations) asynchronously in parallel multiple streams are instantiated. In each one of them different kernels are lunched to compute accelerations and evolution steps. 

We find that the implementation can actually parallelise different simulation without any particular performance loss. Moreover the procedure suffers from the algotrithm implemented for the acceleration estimation that makes the time required grow quadratically as the number of particles increases.

### Part 2 - Data Analysis

Stellar clusters orbiting in and around a galaxy are subject to the tidal field of that galaxy. Comparing the potential field generated by the galaxy and the one generated by the stellar cluster it is possible to define a tidal radius

$$
\begin{equation*}
r_t \approx r_G \biggl(\frac{m_{cl}}{M_G}\biggr)^{1/3}
\end{equation*}
$$

where $r_G$ is the distance of the stellar cluster from the center of the galaxy, $M_G$ is the mass of the galaxy within $r_G$ and $m_{cl}$ is the mass of the stellar cluster. At $r > 2r_t$ the potential generated by the galaxy starts to dominate over the potential of the cluster, therefore we can consider the star escaped by the stellar system. Therefore, along the orbit, the stellar cluster loses mass creating stellar streams. In some cases, the stellar cluster is destroyed. 

We studied two realizations of the systems. The results can be found inside the report.


## The Fireworks Python Package

Fireworks is a Python library that contains tools to initialize and evolve N-body systems and it can be used to simulate collisionless systems, collisional systems and orbit integration. It also contains some other useful tools as `pyfalcon` and `TSUNAMI`. \
Fireworks contains the following submodules: 
- `particles`: it contains the class `Particles` in which all the information about the particles can be stored (position, velocity, mass), and it provides useful tools to retrieve physical quantities of the system (e.g. CoM quantities, potential, kinetic and total energies);

- `ic`: it contains functions through which initial conditions can be generated. The module contains two functions: `ic_random_normal`, which draws initial conditions from a normal distribution, and `ic_two_body`, which generates initial conditions for the case of a two-body system;

- `Nbodylib`: it contains functions to estimate the gravitational forces and accelerations. It is divided into other four modules:
    - `dynamics`: it contains functions to estimate accelerations due to gravitational forces. `acceleration_pyfalcon`, used in our work, is a function of this module. In this module we can find our ad hoc built acceleration estimate functions: `acceleration_direct` and `acceleration_direct_vectorized`. The first computes gravitational acceleration between particles using a direct method (i.e. for loops), while the latter leverages the broadcasting operations of `numpy.array`.

    - `integrators`: it contains integrators used to integrate the ODE equations of the motion and evolve the system in time. `integrator_leapfrog`, used in our work, is a function of this module;
  
    - `nunits`: it contains the class `Nbody_units`, necessary to transform the data from physical units to N-body units or vice-versa;

    - `potentials`: it contains a collection of classes and functions to estimate acceleration due to gravitational forces of a fixed potential. In this module, we can find some classes among them `Potential_Base`, used to initialize new potentials, and `Point_Mass`, which assumes the presence of a point of mass M fixed at the center of the frame of reference.
  
    - `timesteps`: it contains functions to estimate the adaptive timestep for the N-body integrations.

### Folders organization
- `Docker`: it contains the files to create a Docker container with the `tsunami` integrator.
- `Fireworks`: it contains the scripts of the `fireworks` module.
- `Project`: it contains several subfolders regarding the final project:
    - `images`: 
        -`plummer_sph`: it contains plots and images produced during the _part 2_ of the project.
    - `plummer_sph_data`: it contains different initial realizations of a Plummer sphere in virial equilibrium.
    - `reports`: it contains the final reports divided in two parts.
    - `presentations`: it contains the link for the .pptx presentation of the project.

- `assignmet_*`: it contains the material produced for the in-itinere assignments.

## Contribution
- Gabriele Bertinelli (@Berto70)
- Diego Bonato (@diegobonato)
- Giacomo Di Prima (@GiacomoDiPrima)
- Giuseppe Viterbo (@vepe99)

------
##### Mark

30 e Lode (30/30 with honors)
